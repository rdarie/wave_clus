function [generated_files] = DS_sort_nev_file(filename, varargin)
%     DS_SORT   Perform density sorting
%         [GENERATED_FILES] = DS_SORT_NEV_FILE(FILENAME, VARARGIN)
%
%     Output:
%       generated_files: structure with paths to all files generated by this
%       function.
%
%     Originally written as DS_sort.m by Carlos E Vargas-Irwin.
%     Refactored as a function by Jonas B Zimmermann on 2016-05-28.
%     Copyright (c) 2016 Jonas B Zimmermann & Brown University.
%     All rights reserved.

options = struct();
options.PlotProgress = 2;
options.LogLevel = 1; % 1: verbose, 2: info, 3: warning, 4: error
options.Save.MAT = true; % Save results as a matlab mat file
options.Save.NEV = true; % save results as a new nev file
options.Save.Events = true; % save non-neural events in nev file
options.Save.Noise = true; % save waveforms classified as noise in nev file
options.Save.SortedSuffix = '_DSXII'; % gets appended to original filename when saving NEV
options.Save.OutPath = 'derived';
options.Save.PlotPath = fullfile(options.Save.OutPath, 'sort_plots');

options.SortChannels = 1:128;% The e_list parameter sets the list of electrodes the program will sort
% (to save time, you can include only 'good' channels, if you have this information beforehand)
% To sort all the channels, simply set it to: e_list = [1:128] or e_list = [1:96]

options.Grid = 100;  % determines how pc space is partitioned
options.LocalMaxRange = 5; % determines the range of local max in the density matrix
options.MinDensity = 2;  % minimum required density for template extraction regions (% of global max)

options.ThresholdCoverage = 99.99;
options.OverlapThresholdCoverage = 98;
options.TemplateThresholdCoverage = 80;

options.ThresholdBounds = [30 100];
options.OverlapThresholdBounds = [30  100];
options.TemplateThresholdBounds =  [30 100];

% Additionally, the amplitude variation threshold
% can be used to increase the normal threshold for each unit
% based on a percent value of its amplitude. This will make the algorithm
% tolerate greater changes in spike shape for units with large amplitude
% signals.
options.AmplitudeVariationThreshold = 15;

options.TemplateVarLimit = 4.5; % If this number times the mean standard deviation
% for the waveforms used to calculate a template
% (those within the center of a cluster) is smaller than the
% amplitude of the template, it is NOT used for clasification.

options.TroughPeakWidthLimit = 0.8; % this sets the maximum acceptable distance between
% trough and peak of valid templates (in milliseconds).
% If set to inf, anything goes.

if nargin > 1
	options = nest_struct_merge(varargin{1}, options);
end

generated_files = struct();

[file_path, fn_ext, ~] = fileparts(filename);
last_sorted_e = 0;

% Want to know how this works? Check out DS_sort_parameters.m

%%%%%%%%%% code follows, no need to read further! Unless you love code.

if options.PlotProgress > 0
    amp_fig_h = 210;
    amp_fig_h = figure(amp_fig_h);
    dens_fig_h = 10;
    dens_fig_h = figure(dens_fig_h);
end

%load file using NPMK toolbox!
NEV = openNEV(filename, 'read', 'report',  'nowarning','nosave', 'nomat' );


tic % how long does this take anyways?

if options.PlotProgress
	plot_out_path = options.Save.PlotPath;
	[~, ~, mkdirmesstr] = mkdir(plot_out_path);
	if ~(strcmp(mkdirmesstr,'MATLAB:MKDIR:DirectoryExists')|| strcmp(mkdirmesstr,''))
		error('Directory %s couldn''t be created.\n', plot_out_path);
	end

end

if options.Save.NEV || options.Save.MAT
    out_path = options.Save.OutPath;
    [~, ~, mkdirmesstr] = mkdir(out_path);
    if ~(strcmp(mkdirmesstr,'MATLAB:MKDIR:DirectoryExists')|| strcmp(mkdirmesstr,''))
        error('Directory %s couldn''t be created.\n', out_path);
    end

    savefname = fullfile(out_path, [fn_ext, options.Save.SortedSuffix, '.nev']);

    parameter_file_name = fullfile(out_path, [fn_ext, options.Save.SortedSuffix, '_sort_parameters.mat']);
    mat_file_name = fullfile(out_path, [fn_ext, options.Save.SortedSuffix, '_sorted_data']);

end

if options.Save.NEV    %save results in a new sorted nev file
    %check if sorted file already exists! (for example, if sorting was
    %interrupetd
    sort_exists = fopen(savefname);
    if(sort_exists == -1) %if it does not exist, create a new file with the same header as the original
        %%%%%%%%%%%%%%%%
        copyNevHeader(filename, savefname);
        %%%%%%%%%%%%%%%%
        %begin sorting at electrode # 1 in list
        starte = 1;
    else % the file already exists


        %close file for now
        fclose(sort_exists);
        %load previous sorting results & parameters
       % load([ savefname(1:end-4) '_sorted_data' ]);
        load(parameter_file_name);
        %Begin sorting at the appropriate place in the electrode list
        starte = last_sorted_e +1;

        printLog(sprintf(':::::::::: Sorted file already exists! Sort will continue from breakpoint at electrode  --->  %i', starte));

    end
end

options
% convert TroughPeakWidthLimit to samples
options.TroughPeakWidthLimit = options.TroughPeakWidthLimit * NEV.MetaTags.SampleRes / 1e3;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

last_sorted_e = 0;
nunits = 0;
% for each electrode number
for n = starte:length(options.SortChannels)
    % beginning of try-catch block to deal with any problematic channels...
    try

    e = options.SortChannels(n);

    printLog(sprintf(':::::::::::::::::::::::: Sorting Channel --->  %i', e));

    printLog(':::::::: Extracting waves and timestamps...');


    if (str2num(NEV.MetaTags.FileSpec) >= 2.3)
        waves = double(NEV.Data.Spikes.Waveform(:,NEV.Data.Spikes.Electrode == e)) / 4;   % divide amplitudes by four for filespec 2.3
    else
        waves = double(NEV.Data.Spikes.Waveform(:,NEV.Data.Spikes.Electrode == e));
    end

    timestamps = double(NEV.Data.Spikes.TimeStamp(:,NEV.Data.Spikes.Electrode == e));



%            %%%   crop data for testing purposes
%            waves = waves(:,1:10000);
%            timestamps = timestamps(1:10000);
%            %%%


    [points, ~] = size(waves);
    if( points == 1)
        waves = waves';
    end
    [~, nw] = size(waves);

    noise_index = 1:nw; %overwritten if any sorting templates are found
    if (nw>100) % if there are any waves for this electrode nubmer

        printLog(':::::::: Calculating Principal Components...', 1);

        % Use subset of waves to calculate principal components
        dec = round(nw / 3000);
        if(dec>1)
            pc = getPC(waves(:,1:dec:nw));
        else
            pc = getPC(waves);
        end
        %%%%%%%%%%
        printLog(':::::::: Projecting waves onto PC space...', 1);
        pcp = getPCP(waves,pc,2);

        printLog(':::::::: Analyzing density matrix & extracting templates...', 1);
        [cent_reg, outline, mean_waves, mw_sd, cr_wnum, pc_means, sortmat_us, sortmat] = DENGRICC_XI(pcp,waves, options.Grid, options.LocalMaxRange, options.MinDensity, options.PlotProgress-2);

        if(isempty(mean_waves))
            printLog(':::::::: No valid templates extracted from the density matrix...');
        else
            % set parameters for this channel
            [ templates{n}, cent_reg_p{n}, outlines_p{n}, cr_wnum_p{n},   mw_sd_p{n}, threshold(n), overlap_threshold(n), template_threshold(n)] = autoset_parameters( waves, cent_reg, outline, cr_wnum, mean_waves,  mw_sd, options.ThresholdCoverage, options.OverlapThresholdCoverage, options.TemplateThresholdCoverage, options.ThresholdBounds, options.OverlapThresholdBounds, options.TemplateThresholdBounds, options.AmplitudeVariationThreshold, options.TemplateVarLimit, options.TroughPeakWidthLimit);

            if ~ isempty(templates{n})

                %                     if(options.PlotProgress)
                %                             close all
                %                             figure(20)
                %                             title([fname(1:end-4) '_DSXI_sig_' num2str(e)]')
                %                             hold on
                %                     end

                printLog(':::::::: Applying Templates...');
                if options.PlotProgress
                    [sorted_ts, noise_index, rec_waves, noise_amp(n)]= SWADE_XI(waves, timestamps, pcp, cent_reg_p{n}, outlines_p{n}, cr_wnum_p{n}, templates{n},  mw_sd_p{n}, threshold(n), options.AmplitudeVariationThreshold, overlap_threshold(n), template_threshold(n), dens_fig_h);
                else
                    [sorted_ts, noise_index, rec_waves, noise_amp(n)]= SWADE_XI(waves, timestamps, pcp, cent_reg_p{n}, outlines_p{n}, cr_wnum_p{n}, templates{n},  mw_sd_p{n}, threshold(n), options.AmplitudeVariationThreshold, overlap_threshold(n), template_threshold(n), 0);
                end

                if(~isempty(sorted_ts{1}))
                    if options.PlotProgress
                        %print('-djpeg', ['sort_results_' num2str(e)]);
                        dens_fn = fullfile(plot_out_path, sprintf('%s_DSXII_sig_%i', fn_ext, e));
                        print(dens_fig_h, '-dpng', dens_fn);
                        generated_files.Channel(e).Density = dens_fn;
                    end


                    if options.PlotProgress > 1 %display amp vs. time plots

                        clf(amp_fig_h)
                        colstr = 'rbgmcrbgmc';
                        for nrw = 1:length(rec_waves)
                            [~, nrecwaves] = size(rec_waves{nrw});
                            all_amp = zeros(1,nrecwaves);
                            for wav = 1:nrecwaves
                            all_amp(wav) = max(rec_waves{nrw}(:,wav)) - min(rec_waves{nrw}(:,wav));
                            end
                            ax_h = subplot(1,length(rec_waves),nrw, 'parent', amp_fig_h);
                            plot(sorted_ts{nrw}/1800000, all_amp,[colstr(nrw) '.'], 'parent', ax_h);
                            hold(ax_h, 'on');
                            set(ax_h, 'fontsize', 13)
                            xlabel('time (min)', 'parent', ax_h)
                            ylabel('amplitude (µV)', 'parent', ax_h)

                            axis(ax_h, [ 0 max(sorted_ts{1}/1800000) 0  (max(max([templates{n}])) - min(min([templates{n}])) )*2] )
                        end

                        amp_fn = fullfile(plot_out_path, sprintf('%s_DSXII_sig_%i_AvT', fn_ext, e));
                        print(amp_fig_h, '-dpng', amp_fn);
                        generated_files.Channel(e).AmplitudeVsTime = amp_fn;
                    end





                    % create an index of sorted timestamps
                    %    unit_index --> 2x#units matrix. The top row should have the channel number
                    %              and the bottom row the unit number.

                    printLog(':::::::: Saving Results...');
                    for nsc = 1:length(sorted_ts)
                        nunits = nunits+1;
                        %Store results in matlab (just timestamps, so it does not take too much space)
                        unit_index(1,nunits) = e;
                        unit_index(2,nunits) = nsc;
                        sorted_timestamps{nunits} = sorted_ts{nsc};
                        if options.Save.NEV
                            % save results to new nev file
                            ect = zeros(1,length(sorted_ts{nsc})) + e;
                            u = zeros(1,length(sorted_ts{nsc})) + nsc;
                            printLog(':::::::: writing spike waves to nev...');
                            %%%%%%%%%%%%%%%%
                            insertSpike(savefname, sorted_ts{nsc}, ect, u, rec_waves{nsc}*4);
                            generated_files.Sort.NEV = savefname;
                            %%%%%%%%%%%%%%%%
                        end
                    end

                    %%%%% Save matlab file
                    if options.Save.MAT
                        for i_ch = 1:length(sorted_timestamps)
                            sorted_timestamps{i_ch} = sorted_timestamps{i_ch} / double(NEV.MetaTags.SampleRes);
                        end
                        save(mat_file_name, 'sorted_timestamps', 'unit_index', 'templates', 'options');
                        generated_files.Sort.MAT = mat_file_name;
                    end
                    %save parameters
                    last_sorted_e = n;
                    save( parameter_file_name, 'options', 'filename', 'savefname', 'last_sorted_e');
                    generated_files.Sort.Parameters = parameter_file_name;
                    %%%%%%%%%%%

                end
            end
        end % if(isempty(mean_waves)

        if options.Save.NEV && options.Save.Noise
            %add noise waveforms to NEV
            ect = zeros(1,length(noise_index)) + e;
            u = zeros(1,length(noise_index));
            printLog(':::::::: writing noise waves to nev...');
            %%%%%%%%%%%%%%%%
            insertSpike(savefname, timestamps(noise_index), ect, u, waves(:,noise_index)*4);
            %%%%%%%%%%%%%%%%
        end


    end %(nw>0)

        catch ME%any errors sorting a given channel
            printLog(sprintf(' ----!---- Error: Unable to sort Channel %i ----!----', e), 4)
            warning(getReport(ME,'extended'))
            printLog(' ----!---------------------------------------------!----', 4)
            if options.Save.Noise
                %add noise waveforms to NEV
                ect = zeros(1,length(noise_index)) + e;
                u = zeros(1,length(noise_index));
                printLog(':::::::: writing noise waves to nev...');
                %%%%%%%%%%%%%%%%
                insertSpike(savefname, timestamps(noise_index), ect, u, waves(:,noise_index)*4);
                %%%%%%%%%%%%%%%%
            end
        end

end  % for n = 1:length(options.SortChannels)

% close nev file

if(options.Save.NEV && options.Save.Events)
    %closeNEV(nevOb)
    %%%%%%%%%%%%%%%%%
    %Copy events from original nev file
	saveNEVWithExtraData(savefname, savefname, 'comment_struct', NEV.Data.Comments, 'serdig_struct', NEV.Data.SerialDigitalIO);
    generated_files.Sort.NEV = savefname;

    %%%%%%%%%%%%%%%%%
end



elapsed_time = toc;
printLog(sprintf('\nElapsed time: %5.0fs\n\n', elapsed_time));

    function printLog(message, loglevel)
        if nargin < 2
            loglevel = 2; % default: info
        end
        if loglevel >= options.LogLevel
            fprintf('%s\n', message);
        end
    end
end %  function

